module Melt
  module Formatters
    # Netfilter implementation of a Melt formatter.
    class Netfilter < Base
      # Returns a Netfilter String representation of the provided +rule+ Rule.
      def emit_rule(rule)
        parts = []
        on_direction_flag = { in: '-i', out: '-o', }
        if rule.nat? then
          parts << '-A POSTROUTING'
          parts << "-o #{rule.on}"
          parts << '-j MASQUERADE'
        elsif rule.rdr? then
          parts << '-A PREROUTING'
          parts << "-i #{rule.on}" if rule.on
          parts << "-p #{rule.proto}" if rule.proto
          parts << "-s #{emit_address(rule.from[:host])}" if rule.from && rule.from[:host]
          parts << "--sport #{rule.src_port}" if rule.from && rule.src_port
          parts << "-d #{emit_address(rule.to[:host])}" if rule.to && rule.to[:host]
          parts << "--dport #{rule.dst_port}" if rule.to && rule.dst_port
          parts << '-j DNAT'
          parts << "--to-destination #{rule.rdr_to[:host]}"
        else
        parts << "-A #{iptables_direction(rule.dir)}"
        if rule.on then
          if rule.on =~ /!(.*)/ then
            parts << "! #{on_direction_flag[rule.dir]} #{$1}"
          else
            parts << "#{on_direction_flag[rule.dir]} #{rule.on}"
          end
        else
          if rule.in then
            parts << "-i #{rule.in}"
          end
          if rule.out then
            parts << "-o #{rule.out}"
          end
        end
        parts << "-p #{rule.proto}" if rule.proto
        parts << "-s #{emit_address(rule.from[:host])}" if rule.from && rule.from[:host]
        parts << "--sport #{rule.src_port}" if rule.src_port
        parts << "-d #{emit_address(rule.to[:host])}" if rule.to && rule.to[:host]
        parts << "--dport #{rule.dst_port}" if rule.dst_port
        parts << "-j #{iptables_action(rule)}"
        end
        parts.join(' ')
      end

      # Returns a Netfilter String representation of the provided +rules+ Array of Rule with the +policy+ policy.
      def emit_ruleset(rules, policy = :block)
        nat_rules    = rules.select { |r| r.nat? || r.rdr? }
        filter_rules = rules.select { |r| [:pass, :block, :log].include?(r.action) }

        parts = []
        parts << "# Generated by melt v#{Melt::VERSION} on #{Time.now.strftime('%c')}"

        if nat_rules.count > 0 then
          parts << '*nat'
          parts << ":PREROUTING ACCEPT [0:0]"
          parts << ":INPUT ACCEPT [0:0]"
          parts << ":OUTPUT ACCEPT [0:0]"
          parts << ":POSTROUTING ACCEPT [0:0]"
          parts << super(nat_rules.select { |r| r.rdr? })
          parts << super(nat_rules.select { |r| r.nat? })
          parts << 'COMMIT'
        end

        parts << '*filter'
        parts << ":INPUT #{iptables_action(policy)} [0:0]"
        parts << ":FORWARD #{iptables_action(policy)} [0:0]"
        parts << ":OUTPUT #{iptables_action(policy)} [0:0]"
        parts << '-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT'
        parts << super(filter_rules.select { |r| r.filter? && r.in? })
        parts << '-A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT'
        parts << super(filter_rules.select { |r| r.fwd? })
        parts << super(filter_rules.select { |r| r.rdr? }.collect { |r| if r.dir == :in then r.in ||= r.on else r.out ||= r.on end; r.to.merge!(r.rdr_to.reject { |k,v| v.nil? }); r.rdr_to = nil; r.dir = :fwd; r.on = nil; r })
        parts << '-A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT'
        parts << super(filter_rules.select { |r| r.filter? && r.out? })
        parts << 'COMMIT'

        parts.reject { |s| s.empty? }.join("\n")
      end

    protected
      def emit_forward_rule(rule)
        parts = []
        parts << '-A FORWARD'
        parts += emit_on(rule)
        parts += emit_jump(rule)
      end

      def emit_on(rule)
        if rule.on && rule.dir then
          on_direction_flag = { in: '-i', out: '-o', }
          [ "#{on_direction_flag[rule.dir]} #{rule.on}" ]
        else
          []
        end
      end

      def emit_src(rule)
        [ "-s #{rule.src[:host]}" ]
      end

      def emit_jump(rule)
        [ "-j #{iptables_action(rule)}" ]
      end

    private
      def iptables_direction(direction)
        case direction
        when :in then 'INPUT'
        when :out then 'OUTPUT'
        when :fwd then 'FORWARD'
        end
      end

      def iptables_action(rule_or_action)
        action, ret = if rule_or_action.is_a?(Symbol) then
                        [rule_or_action, nil]
                      elsif rule_or_action.is_a?(Rule) then
                        [rule_or_action.action, rule_or_action.return]
                      else
                        raise "Unexpected #{rule_or_action.class.name}"
                      end
        case action
        when :pass then 'ACCEPT'
        when :log then 'LOG'
        when :block then
          if ret then
            'RETURN'
          else
            'DROP'
          end
        end
      end
    end
  end
end
