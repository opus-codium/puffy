# frozen_string_literal: true

require 'puffy'

module Puffy
  module Formatters
    RSpec.describe Pf::Rule do
      subject(:formatter) { described_class.new }

      it 'formats simple rules' do
        rule = Rule.new(action: :pass, dir: :out, proto: :tcp)
        expect(formatter.emit_rule(rule)).to eq('pass out quick proto tcp')

        rule = Rule.new(action: :pass, dir: :in, proto: :tcp, to: { host: nil, port: 80 })
        expect(formatter.emit_rule(rule)).to eq('pass in quick proto tcp to any port 80')

        rule = Rule.new(action: :block, dir: :in, proto: :icmp)
        expect(formatter.emit_rule(rule)).to eq('block in quick proto icmp')

        rule = Rule.new(action: :pass, dir: :in, proto: :udp, from: { port: 123 }, to: { port: 123 })
        expect(formatter.emit_rule(rule)).to eq('pass in quick proto udp from any port 123 to any port 123')

        rule = Rule.new(action: :pass, dir: :in, proto: :tcp, from: { port: 67..68 }, to: { port: 67..68 })
        expect(formatter.emit_rule(rule)).to eq('pass in quick proto tcp from any port 67:68 to any port 67:68')
      end

      it 'generates non-quick rules' do
        rule = Rule.new(action: :block, dir: :in, no_quick: true)
        expect(formatter.emit_rule(rule)).to eq('block in all')
      end

      it 'returns packets when instructed so' do
        rule = Rule.new(action: :block, return: true, dir: :in, proto: :icmp)
        expect(formatter.emit_rule(rule)).to eq('block return in quick proto icmp')
      end

      context 'when formatting redirect rules' do
        it 'formats redirect rules' do
          rule = Rule.new(action: :pass, dir: :in, on: 'eth0', proto: :tcp, to: { port: 80 }, rdr_to: { host: IPAddr.new('127.0.0.1/32'), port: 3128 })
          expect(formatter.emit_rule(rule)).to eq('pass in quick on eth0 proto tcp to any port 80 divert-to 127.0.0.1 port 3128')
        end

        it 'fails on ambiguous redirect rule' do
          rule = Rule.new(action: :pass, dir: :in, on: 'eth0', proto: :tcp, to: { port: 80 }, rdr_to: { port: 3128 })
          expect { formatter.emit_rule(rule) }.to raise_exception('Unspecified address family')
        end

        it 'formats implicit IPv4 destination' do
          rule = Rule.new(action: :pass, dir: :in, on: 'eth0', af: :inet, proto: :tcp, to: { port: 80 }, rdr_to: { port: 3128 })
          expect(formatter.emit_rule(rule)).to eq('pass in quick on eth0 proto tcp to any port 80 divert-to 127.0.0.1 port 3128')
        end

        it 'formats implicit IPv6 destination' do
          rule = Rule.new(action: :pass, dir: :in, on: 'eth0', af: :inet6, proto: :tcp, to: { port: 80 }, rdr_to: { port: 3128 })
          expect(formatter.emit_rule(rule)).to eq('pass in quick on eth0 proto tcp to any port 80 divert-to ::1 port 3128')
        end
      end

      context 'when using an implicit address family' do
        it 'skips redundant address family' do
          rule = Rule.new(action: :pass, dir: :in, af: :inet, proto: :tcp, to: { host: IPAddr.new('127.0.0.1') })
          expect(formatter.emit_rule(rule)).to eq('pass in quick proto tcp to 127.0.0.1')
          rule = Rule.new(action: :pass, dir: :in, af: :inet6, proto: :tcp, to: { host: IPAddr.new('::1') })
          expect(formatter.emit_rule(rule)).to eq('pass in quick proto tcp to ::1')
          rule = Rule.new(action: :pass, dir: :in, af: :inet, proto: :tcp, to: { port: 80 })
          expect(formatter.emit_rule(rule)).to eq('pass in quick inet proto tcp to any port 80')
          rule = Rule.new(action: :pass, dir: :in, af: :inet6, proto: :tcp, to: { port: 80 })
          expect(formatter.emit_rule(rule)).to eq('pass in quick inet6 proto tcp to any port 80')
        end
      end
    end

    RSpec.describe Pf::Ruleset do
      subject(:formatter) { described_class.new }

      context 'with a ruleset' do
        let(:parser) do
          parser = Puffy::Parser.new
          parser.parse(File.read(File.join('spec', 'fixtures', 'simple_lan_network.puffy')))
          parser
        end
        let(:policies) do
          {
            in:  { action: :block },
            out: { action: :block },
          }
        end

        before do
          Timecop.freeze('2000-01-01 00:00:00')
        end

        after do
          Timecop.return
        end

        it 'generates the correct gw rules' do
          rules = parser.ruleset_for('gw')
          expect(formatter.emit_ruleset(rules, policies)).to eq <<~PF
            # Generated by puffy v#{Puffy::VERSION} on Sat Jan  1 00:00:00 2000
            match in all scrub (no-df)
            set skip on lo
            block in all
            block out all
            pass out quick on ppp0 nat-to 198.51.100.72
            pass in quick on ppp0 proto tcp to any port 80 rdr-to 192.168.1.80
            pass out quick proto udp to 192.168.0.53 port 53
            pass out quick proto udp to 192.168.1.53 port 53
          PF
        end

        it 'generates tE correct www rules' do
          rules = parser.ruleset_for('www')
          expect(formatter.emit_ruleset(rules, policies)).to eq <<~PF
            # Generated by puffy v#{Puffy::VERSION} on Sat Jan  1 00:00:00 2000
            match in all scrub (no-df)
            set skip on lo
            block in all
            block out all
            pass out quick proto udp to 192.168.0.53 port 53
            pass out quick proto udp to 192.168.1.53 port 53
            pass in quick proto tcp to any port 80
          PF
        end
      end
    end
  end
end
